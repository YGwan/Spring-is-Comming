# spring-is-coming

#### Spring framework를 다루기 위한 기본부터 시작하기

<br>

- Http 
- HttpServlet 직접 구현해보기
- SpringMVC
- JDBC
- Spring JDBC
- JWT를 사용한 인증 구현
- KeyHolder를 사용한 자동 id값 생성
- ExceptionHandler, ControlerAdvice를 사용한 에러 처리 구현

---
### 개발 환경 선택 이유

#### Gradle - Groovy Project 선택 이유

- XML 기반 스크립트에 비해 관리가 편하기 때문에 사용 (Groovy 문법으로 간결한 스크립트 작성 가능)
- 캐싱을 통한 빌드 속도가 빠릅니다.
- 안드로이드 프로젝트의 표준 빌드 시스템으로 채택되어 있습니다.
- 현재는 Maven -> Gradle로 넘어가는 추세이기 때문에

<br>

#### java 11 버전 사용 이유
- LTS를 지원하는 버전이므로
- Stream, Lambda 등을 지원하는 버전 중 적당한 시기에 나왔고 어느정도 안정성을 보장하는 버전이기 때문에
- spring과의 호환성이 좋기 때문에

---

### 코드 작성 시 고민했던 내용

<br>

> Query문에서 =, EXISTS, IN의 차이가 뭘까요?

```
"exist"는 존재 여부를 판단하고 결과는 참 또는 거짓입니다.(여러 값 비교)
"in"은 값이나 집합에 속하는지 여부를 판단하고 결과는 참 또는 거짓입니다.(여러 값 비교)
"="은 두 값이 동일한지 여부를 판단하고 결과는 참 또는 거짓입니다.(단일 값 비교)

EXISTS는 조건에 해당하는 ROW의 존재 유무와 체크 후 더이상 수행하지 않지만 IN의 경우 조건에 해당하는 ROW의 컬럼을 비교하여 체크한다. 즉 EXISTS은 SELECT 절을 평가하지 않으므로 일반적으로 IN에 비해 성능이 좋습니다.
EXISTS : 메인 쿼리의 결과값을 서브 쿼리에 대입하여 조건 비교 후 결과를 출력한다. ( 메인쿼리 -> EXISTS 쿼리 )
IN : 서브 쿼리의 결과값을 메인 쿼리에 대입하여 조건 비교 후 결과를 출력한다. ( IN쿼리 -> 메인 쿼리 )
```

<br>

> 프로젝트에서 토큰을 다루기 위해 이 의존성들이 모두 필요한가요?

```
jjwt-api는 토큰 생성을 위한 객체들을 추상화 하기 위한 라이브러리입니다.
jjwt-impl는 JJWT 라이브러리의 구현을 가리킵니다. 이 종속성을 Java 프로젝트로 가져오면 JJWT 라이브러리에서 제공하는 클래스 및 메서드에 액세스하여 JWT를 사용할 수 있습니다.
jjwt-jackson의 경우 JWT의 JSON 직렬화 및 역직렬화를 처리하기 위해 JJWT(Java JWT)와 함께 자주 사용되는 또 다른 종속성입니다. (그런데 jjwt-jackson의 종속성을 추가하지 않고 실행했을때 실행은 원활하게 됐는데 실제 jwt를 생성하는 과정에서 에러가 발생하는 것을 확인했습니다. 따라서 최종적으로 해당 종속성을 다시 추가하니 문제 없이 돌아가는 것을 확인했습니다.)
 그러므로 토큰을 생성 & 다루기 위해서는 3가지의 종속성이 다 필요합니다.

```

<br>

> JWT Token의 payLoad에 들어가야할 내용이 뭘까요?

```
JWT TOKEN은 크게 Header, payLoad, SIGNATURE 이렇게 3부분으로 나누어져 있습니다.

Header (헤더): JWT 토큰의 헤더는 토큰의 타입과 해싱 알고리즘을 지정합니다. 일반적으로 JSON 형식으로 표현되며 다음과 같은 구조를 갖습니다.
Payload (페이로드): JWT 토큰의 페이로드는 클레임(claim)이라고도 불리는 정보를 포함합니다.
Signature (서명): 헤더와 페이로드를 이용하여 서명된 부분입니다. 서명은 토큰이 유효한지 검증하는 데 사용됩니다.
 즉, 페이로드에 사용자를 구분할 수 있는 정보가 들어갑니다. 이를 통해 앱 내에서 사용자의 정보를 가져올때 쓸 수 있습니다. 그런데, 페이로드의 경우 SecretKey가 없이도 해석(Decoding)이 가능합니다.
발급 받은 토큰을 jwt.io에다가 넣게 되면 SecretKey없이 해당 페이로드의 정보를 가져올 수 있는 것을 확인할 수 있습니다. 즉, 페이로드에는 사용자의 중요한 정보(비밀번호 등)을 넣으면 안됩니다.
SecretKey는 서명 부분에 사용되며 해당 키를 통해 토큰이 유효한지 검증할 수 있습니다.
```

<br>

> 메서드명 validate & valid의 개발자가 바라보는 관점의 차이가 뭘까요?

```
valid는 '유효한' 이라는 의미입니다. 따라서 개발자들은 해당 단어로 시작하는 함수명(validLogIn, validPasswd 등)을 보고 해당 함수의 동작의 반환으로 true & false값을 기대할 것입니다.
validate는 '검증/확인하다'의 의미입니다. 따라서 개발자들은 해당 단어로 시작하는 함수명(validateLogIn, validatePasswd 등)을 보고 해당 함수의 동작의 반환으로 void값을 기대할 것입니다.
 이런 부분의 경우 나만의 스타일을 가지고 정하거나 현재 통용되고 있는 형식에 맞춰 하는것이 팀 프로젝트에서 매우 중요하다는 것을 느꼈습니다.
```

<br>

> DB에러를 바로 사용자에게 보여줘도 될까요?

```
DB에러의 경우 사용자에게 바로 보여주는 것은 좋지 않습니다. DB오류의 내용을 사용자에게 노출하면 해커나 악의적인 사용자가 정보를 얻을 수 있습니다. 이러한 정보를 통해 공격을 할 수 있기 때문에 보안상 이유로 바로 보여주는 것은 안전하지 않습니다.
 또한, DB에러의 경우 로그의 역할로써 개발자를 위한 디버깅 도구로서는 의미가 있지만 사용자에게는 사용자에게 혼동을 주거나 사용자 경험을 저하하는 등의 부정적인 영향을 끼칠 수 있습니다.(서비스에 대한 신뢰도 저하 등)
 따라서 사용자에게 DB 오류 메시지를 직접 보여주는 대신, 시스템은 안정성을 유지하고 개발자에게 알림을 보내는 것이 좋습니다. 개발자는 알림을 받고 빠르게 DB 오류를 확인하고 해결할 수 있습니다. 사용자에게는 친절한 오류 메시지를 제공하여 문제가 발생했음을 알리고, 개발자가 조치를 취하고 시스템을 복구할 때까지 기다리도록 안내하는 것이 바람직합니다.
```

<br>

---

### 주요 관점 및 배운 내용

1. 주석 없이 해당 함수 or 변수가 어떤걸 의미하는지 알 수 있는 명확한 변수명을 선택하기
2. DB에서 나는 에러는 사용자에게 바로 보여지면 안되고 항상 필터링 해서 보여주기(해킹 위험)
3. 의미 없는 줄 바꿈이나, 클래스 간 코드 형식을 항상 고려해서 코드를 작성하기
4. 초반 설계의 중요성 (DB를 합쳐보면서 초반 설계를 잘못하면 대규모 프로젝트에서는 매우 힘들겠다는 것을 느꼈습니다.)
5. 임시 로직, 테스트 용 코드는 리뷰 요청 전에 제거 or 수정하기
6. 스프링의 전반적인 구조 및 사용방법
7. 코드 리뷰 및 팀 프로젝트의 문화를 배웠습니다.(PR, CODE REVIEW, MERGE)


